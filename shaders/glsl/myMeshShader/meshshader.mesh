/* Copyright (c) 2021, Sascha Willems
 *
 * SPDX-License-Identifier: MIT
 *
 */

#version 450
#extension GL_EXT_mesh_shader : require

// layout (binding = 0) uniform UBO 
// {
// 	mat4 projection;
// 	mat4 model;
// 	mat4 view;
// } ubo;

layout (set = 0, binding = 0) uniform UBOScene 
{
	mat4 projection;
	mat4 view;
	vec4 lightPos;
	vec4 viewPos;
} uboScene;

layout (set = 1, binding = 0) uniform UBOModel
{
	mat4 matrix;
#ifdef USE_SKINNING
	mat4 jointMatrix[64];
	float jointcount;
#endif
} uboModel;

struct VertexType
{
	vec3 pos;
	vec3 normal;
	vec2 uv;
	vec4 color;
	vec4 tangent;
#ifdef USE_SKINNING
	vec4 joint0;
	vec4 weight0;
#endif
};
struct Meshlet
{
	/* offsets within meshlet_vertices and meshlet_triangles arrays with meshlet data */
	uint vertexOffset;
	uint triangleOffset;

	/* number of vertices and triangles used in the meshlet; data is stored in consecutive range defined by offset and count */
	uint vertexCount;
	uint triangleCount;
};

layout (set = 3, binding = 0) buffer SSBOVertexBuffer
{
	VertexType vertices[];
}ssboVertices;
layout (set = 3, binding = 1) buffer SSBOMeshlets
{
	Meshlet meshlet[];
}ssboMeshlets;
layout (set = 3, binding = 2) buffer SSBOMeshletsVertexBuffer
{
	uint vertices[];
}ssboMeshletsVertices;
layout (set = 3, binding = 3) buffer SSBOMeshletsIndexBuffer
{
	uint indices[];
}ssboMeshletTriangles;


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 128) out;

layout(location = 0) out VertexOutput
{
	vec4 color;
} vertexOutput[];


const vec4[3] positions = {
	vec4( 0.0, -1.0, 0.0, 1.0),
	vec4(-1.0,  1.0, 0.0, 1.0),
	vec4( 1.0,  1.0, 0.0, 1.0)
};

const vec4[3] colors = {
	vec4(0.0, 1.0, 0.0, 1.0),
	vec4(0.0, 0.0, 1.0, 1.0),
	vec4(1.0, 0.0, 0.0, 1.0)
};

void main()
{
	uint liID = gl_LocalInvocationID.x;
	uint wgID = gl_WorkGroupID; // blockIdx

	Meshlet m = ssboMeshlets[wgid];
	SetMeshOutputsEXT(m.vertexCount, m.triangleCount);

	if (wgID < m.triangleCount)
	{ 
        // meshopt stores the triangle offset in bytes since it stores the
        // triangle indices as 3 consecutive bytes. 
        //
        // Since we repacked those 3 bytes to a 32-bit uint, our offset is now
        // aligned to 4 and we can easily grab it as a uint without any 
        // additional offset math.
        //
        uint packed = ssboMeshletTriangles[m.triangleOffset + wgID];
        uint vIdx0  = (packed >>  0) & 0xFF;
        uint vIdx1  = (packed >>  8) & 0xFF;
        uint vIdx2  = (packed >> 16) & 0xFF;
        gl_PrimitiveTriangleIndicesEXT[wgID] = uint3(vIdx0, vIdx1, vIdx2);
	}

	if (wgID < m.vertexCount)
	{
		uint vertexIndex = m.vertexOffset + wgID;        
        vertexIndex = ssboMeshletsVertices.vertices[vertexIndex];

		mat4 mvp = uboScene.projection * uboScene.view * uboModel.matrix;
		gl_MeshVerticesEXT[0].gl_Position = mvp * ssboVertices.vertices[vertexIndex].pos;

        vertices[gtid].Position = mul(Cam.MVP, float4(ssboVertices.vertices[vertexIndex].pos, 1.0)); // out
        
        float3 color = float3(
            float(gid & 1),
            float(gid & 3) / 4,
            float(gid & 7) / 8);
        vertices[gtid].Color = color;
	}
	vec4 offset = vec4(0.0, 0.0, gl_GlobalInvocationID.x, 0.0);

	mat4 mvp = uboScene.projection * uboScene.view * uboModel.matrix;
	gl_MeshVerticesEXT[0].gl_Position = mvp * (positions[0] + offset);
	gl_MeshVerticesEXT[1].gl_Position = mvp * (positions[1] + offset);
	gl_MeshVerticesEXT[2].gl_Position = mvp * (positions[2] + offset);
	vertexOutput[0].color = colors[0];
	vertexOutput[1].color = colors[1];
	vertexOutput[2].color = colors[2];
	gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationIndex] =  uvec3(0, 1, 2);
}
